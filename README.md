# tasm-lib

This repository contains a collection of functions written in Triton VM assembly (tasm). The functions supplied here emulate the standard library of other programming languages: basic functions that are used a lot.

There are two big projects to be written in tasm. They are not contained in this repository. These projects are:
 - The consensus logic of [Neptune](https://neptune.cash/)
 - The recursive Triton VM STARK verifier (recufier)

This repository helps to benchmark snippets written in tasm in order to gauge the complexity of the (Triton VM) prover.

Please place code in the appropriate directories, or create them if non-existent.

## Conventions
### Memory
Triton-VM has $P = 2^{64} - 2^{32} + 1$ number of words in its RAM, where each word is a prime field element in the prime $P$, colloquially called "0xfoi" due to its hexadecimal representation. RAM can be initialized at startup. The following memory conventions are followed in all snippets:
- The address region $[0, 2^{32})$ is reserved for initialized memory
- The address region $[2^{32}, 2^{64} - 2^{32} + 1)$ is used for dynamically allocated memory, memory that was allocated at runtime. The address $-1$ handles the state of the dynamic allocator
- Statically allocated memory, which is reserved by snippets and compiled code, starts at address $-2$ and grows downwards. Note that $-1 = 2^{64} - 2^{32}$. We don't believe that these memory ranges can overlap in any realistic set of programs, as the memory allocator always gives exactly {1^{32}} words at a time, so a program overwriting statically allocated memory would need to run for at least $2^{32}$ cycles.

### U64
A `u64` type is stored on the stack as two `u32` elements. Triton VM provides native support for `u32`. A `u64` is stored with the least significant part on top of the stack and the most significant part below it. So if the least significant part is `st0`, then the most significant part is stored in `st1`.

### U128
a `u128` is represented by four `u32` values, where each value takes up a word of space in the VM. `u128` follow a similar encoding to that of `u64`: The least significant `u32` value is stored on top of the stack, in `st0`.

## Runtimes
Runtimes are printed in the JSON files in the `benchmarks` directory. These benchmarks count the number of clock cycles it took to execute each benchmark. They also count co-processor use, like u32-table height and hash-table height.

The benchmark results are generated by tests labeled as `benchmark`. If you manage to lower any of the numbers by changing a TASM snippet, please make a pull request, so we can get more efficient algorithms :)

All benchmark results must be deterministic. Any benchmark that does not always generate the same numbers is a bug.
